Index: app/src/main/java/org/freedomtool/feature/onBoarding/logic/NfcReaderTask.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.freedomtool.feature.onBoarding.logic\n\nimport android.content.Context\nimport android.nfc.tech.IsoDep\nimport android.os.AsyncTask\nimport android.util.Log\nimport io.reactivex.subjects.PublishSubject\nimport net.sf.scuba.smartcards.CardService\nimport org.bouncycastle.asn1.cms.SignedData\nimport org.bouncycastle.jce.provider.BouncyCastleProvider\nimport org.freedomtool.utils.nfc.DateUtil\nimport org.freedomtool.utils.nfc.ImageUtil\nimport org.freedomtool.utils.nfc.SecurityUtil\nimport org.freedomtool.utils.nfc.StringUtil\nimport org.freedomtool.utils.nfc.model.AdditionalPersonDetails\nimport org.freedomtool.utils.nfc.model.DocType\nimport org.freedomtool.utils.nfc.model.EDocument\nimport org.freedomtool.utils.nfc.model.Image\nimport org.freedomtool.utils.nfc.model.PersonDetails\nimport org.jmrtd.BACKeySpec\nimport org.jmrtd.PassportService\nimport org.jmrtd.Util\nimport org.jmrtd.lds.CardSecurityFile\nimport org.jmrtd.lds.ChipAuthenticationInfo\nimport org.jmrtd.lds.ChipAuthenticationPublicKeyInfo\nimport org.jmrtd.lds.PACEInfo\nimport org.jmrtd.lds.SODFile\nimport org.jmrtd.lds.icao.DG14File\nimport org.jmrtd.lds.icao.DG15File\nimport org.jmrtd.lds.icao.DG1File\nimport org.jmrtd.lds.icao.DG2File\nimport org.jmrtd.lds.icao.DG5File\nimport org.jmrtd.lds.icao.DG7File\nimport org.jmrtd.lds.iso19794.FaceImageInfo\nimport org.jmrtd.protocol.EACCAResult\nimport java.io.InputStream\nimport java.security.MessageDigest\nimport java.security.SecureRandom\nimport java.security.Security\nimport java.util.Arrays\n\n@OptIn(ExperimentalStdlibApi::class)\nclass NfcReaderTask(\n    private val isoDep: IsoDep,\n    private val bacKey: BACKeySpec,\n    val context: Context\n) :\n    AsyncTask<Void?, String?, Exception?>() {\n    private var eDocument: EDocument = EDocument()\n    private var docType: DocType = DocType.OTHER\n    private var personDetails: PersonDetails = PersonDetails()\n    private var additionalPersonDetails: AdditionalPersonDetails = AdditionalPersonDetails()\n\n    private val resultSubject = PublishSubject.create<EDocument>()\n\n    fun getResultSubject(): io.reactivex.Observable<EDocument> {\n        return resultSubject\n    }\n\n    fun cropByteArray(inputByteArray: ByteArray, endNumber: Int): ByteArray {\n        // Make sure endNumber is within bounds\n        val endIndex = if (endNumber > inputByteArray.size) inputByteArray.size else endNumber\n\n        // Use copyOfRange to crop the ByteArray\n        return inputByteArray.copyOfRange(0, endIndex)\n    }\n\n\n    override fun onProgressUpdate(vararg values: String?) {\n        super.onProgressUpdate(*values)\n        //loadingInfo.setText(values[0])\n    }\n\n    override fun doInBackground(vararg params: Void?): Exception? {\n        try {\n            val cardService = CardService.getInstance(isoDep)\n            cardService.open()\n            val service = PassportService(\n                cardService,\n                PassportService.NORMAL_MAX_TRANCEIVE_LENGTH,\n                PassportService.DEFAULT_MAX_BLOCKSIZE,\n                true,\n                false\n            )\n            service.open()\n            var paceSucceeded = false\n            try {\n                val cardSecurityFile =\n                    CardSecurityFile(service.getInputStream(PassportService.EF_CARD_SECURITY))\n                val securityInfoCollection = cardSecurityFile.securityInfos\n                for (securityInfo in securityInfoCollection) {\n                    if (securityInfo is PACEInfo) {\n                        val paceInfo = securityInfo\n                        service.doPACE(\n                            bacKey,\n                            paceInfo.objectIdentifier,\n                            PACEInfo.toParameterSpec(paceInfo.parameterId),\n                            null\n                        )\n                        paceSucceeded = true\n                    }\n                }\n            } catch (e: Exception) {\n                Log.w(\"Error\", e)\n            }\n            service.sendSelectApplet(paceSucceeded)\n            if (!paceSucceeded) {\n                try {\n                    service.getInputStream(PassportService.EF_COM).read()\n                } catch (e: Exception) {\n                    e.printStackTrace()\n                    service.doBAC(bacKey)\n                }\n            }\n\n            var hashesMatched = true\n            var activeAuth = true\n            var chipAuth = true\n            publishProgress(\"Reading sod file\")\n            val sodIn1 = service.getInputStream(PassportService.EF_SOD)\n\n            val byteArray = ByteArray(1024 * 1024)\n\n            val byteLen = sodIn1.read(byteArray)\n\n\n            val sod = cropByteArray(byteArray, byteLen).toHexString()\n            eDocument.sod = sod\n\n            val sodIn = service.getInputStream(PassportService.EF_SOD)\n\n            val sodFile = SODFile(sodIn)\n\n            sodFile.dataGroupHashes.entries.forEach { (key, value) ->\n                Log.d(\"\", \"Data group: $key hash value: ${StringUtil.byteArrayToHex(value)}\")\n            }\n\n            var digestAlgorithm = sodFile.digestAlgorithm\n            Log.d(\n                \"\",\n                \"Digest Algorithm: $digestAlgorithm\"\n            )\n            val docSigningCert = sodFile.docSigningCertificate\n            val docSigningCerts = sodFile.docSigningCertificates\n            val pemFile: String = SecurityUtil.convertToPem(docSigningCert)\n            Log.d(\n                \"\",\n                \"Document Signer Certificate: $docSigningCert\"\n            )\n            Log.d(\n                \"\",\n                \"Document Signer Certificate Pem : $pemFile\"\n            )\n            val digestEncryptionAlgorithm = sodFile.digestEncryptionAlgorithm\n            val digest: MessageDigest\n            publishProgress(\"Loading digest algorithm\")\n            digest = if (Security.getAlgorithms(\"MessageDigest\").contains(digestAlgorithm)) {\n                MessageDigest.getInstance(digestAlgorithm)\n            } else {\n                MessageDigest.getInstance(digestAlgorithm, BouncyCastleProvider())\n            }\n            publishProgress(\"Reading Personal Details\")\n\n\n            // -- Personal Details -- //\n            val dg1In = service.getInputStream(PassportService.EF_DG1)\n            val dg1File = DG1File(dg1In)\n            var encodedDg1File = String(dg1File.encoded)\n            val mrzInfo = dg1File.mrzInfo\n            personDetails.name =\n                mrzInfo.secondaryIdentifier.replace(\"<\", \" \").trim { it <= ' ' }\n            personDetails.surname =\n                mrzInfo.primaryIdentifier.replace(\"<\", \" \").trim { it <= ' ' }\n            personDetails.personalNumber = mrzInfo.personalNumber;\n            personDetails.gender = mrzInfo.gender.toString();\n            personDetails.birthDate = DateUtil.convertFromMrzDate(mrzInfo.dateOfBirth);\n            personDetails.expiryDate = DateUtil.convertFromMrzDate(mrzInfo.dateOfExpiry);\n            personDetails.serialNumber = mrzInfo.documentNumber;\n            personDetails.nationality = mrzInfo.nationality;\n            personDetails.issuerAuthority = mrzInfo.issuingState;\n\n            //TODO: don't save this\n\n            eDocument.dg1 = encodedDg1File\n\n            if (\"I\" == mrzInfo.documentCode) {\n                docType = DocType.ID_CARD\n                encodedDg1File =\n                    StringUtil.fixPersonalNumberMrzData(encodedDg1File, mrzInfo.personalNumber)\n            } else if (\"P\" == mrzInfo.documentCode) {\n                docType = DocType.PASSPORT\n            }\n            val dg1StoredHash = sodFile.dataGroupHashes[1]\n            val dg1ComputedHash = digest.digest(encodedDg1File.toByteArray())\n            Log.d(\n                \"\",\n                \"DG1 Stored Hash: \" + StringUtil.byteArrayToHex(dg1StoredHash!!)\n            )\n            Log.d(\n                \"\",\n                \"DG1 Computed Hash: \" + StringUtil.byteArrayToHex(dg1ComputedHash)\n            )\n            if (Arrays.equals(dg1StoredHash, dg1ComputedHash)) {\n                Log.d(\"\", \"DG1 Hashes are matched\")\n            } else {\n                hashesMatched = false\n            }\n            publishProgress(\"Reading Face Image\")\n\n            // -- Face Image -- //\n            val dg2In = service.getInputStream(PassportService.EF_DG2)\n            val dg2File = DG2File(dg2In)\n            publishProgress(\"Decoding Face Image\")\n            val dg2StoredHash = sodFile.dataGroupHashes[2]\n            val dg2ComputedHash = digest.digest(dg2File.encoded)\n            Log.d(\n                \"\",\n                \"DG2 Stored Hash: \" + StringUtil.byteArrayToHex(dg2StoredHash!!)\n            )\n            Log.d(\n                \"\",\n                \"DG2 Computed Hash: \" + StringUtil.byteArrayToHex(dg2ComputedHash)\n            )\n            if (Arrays.equals(dg2StoredHash, dg2ComputedHash)) {\n                eDocument.dg2Hash = dg2ComputedHash.toHexString()\n                Log.d(\"\", \"DG2 Hashes are matched\")\n            } else {\n                hashesMatched = false\n            }\n            val faceInfos = dg2File.faceInfos\n            val allFaceImageInfos: MutableList<FaceImageInfo> = ArrayList()\n            for (faceInfo in faceInfos) {\n                allFaceImageInfos.addAll(faceInfo.faceImageInfos)\n            }\n            if (!allFaceImageInfos.isEmpty()) {\n                val faceImageInfo = allFaceImageInfos.iterator().next()\n                val image: Image = ImageUtil.getImage(context, faceImageInfo)\n                personDetails.faceImage = image.bitmapImage\n                personDetails.faceImageBase64 = image.base64Image\n            }\n            publishProgress(\"Reading Portrait Picture\")\n\n            // -- Portrait Picture -- //\n            try {\n                val dg5In = service.getInputStream(PassportService.EF_DG5)\n                val dg5File = DG5File(dg5In)\n\n                val dg5StoredHash = sodFile.dataGroupHashes[5]\n                val dg5ComputedHash = digest.digest(dg5File.encoded)\n                Log.d(\n                    \"\",\n                    \"DG5 Stored Hash: \" + StringUtil.byteArrayToHex(dg5StoredHash!!)\n                )\n                Log.d(\n                    \"\",\n                    \"DG5 Computed Hash: \" + StringUtil.byteArrayToHex(dg5ComputedHash)\n                )\n                if (Arrays.equals(dg5StoredHash, dg5ComputedHash)) {\n                    Log.d(\n                        \"\",\n                        \"DG5 Hashes are matched\"\n                    )\n                } else {\n                    hashesMatched = false\n                }\n                val displayedImageInfos = dg5File.images\n                if (!displayedImageInfos.isEmpty()) {\n                    val displayedImageInfo = displayedImageInfos.iterator().next()\n                    val image: Image = ImageUtil.getImage(context, displayedImageInfo)\n                    personDetails.portraitImage = image.bitmapImage\n                    personDetails.portraitImageBase64 = image.base64Image\n                }\n            } catch (e: Exception) {\n                Log.w(\"\", e)\n            }\n            publishProgress(\"Reading Signature\")\n\n            // -- Signature (if exist) -- //\n            try {\n                val dg7In = service.getInputStream(PassportService.EF_DG7)\n                val dg7File = DG7File(dg7In)\n                val dg7StoredHash = sodFile.dataGroupHashes[7]\n                val dg7ComputedHash = digest.digest(dg7File.encoded)\n                Log.d(\n                    \"\",\n                    \"DG7 Stored Hash: \" + StringUtil.byteArrayToHex(dg7StoredHash!!)\n                )\n                Log.d(\n                    \"\",\n                    \"DG7 Computed Hash: \" + StringUtil.byteArrayToHex(dg7ComputedHash)\n                )\n                if (Arrays.equals(dg7StoredHash, dg7ComputedHash)) {\n                    Log.d(\n                        \"\",\n                        \"DG7 Hashes are matched\"\n                    )\n                } else {\n                    hashesMatched = false\n                }\n                val signatureImageInfos = dg7File.images\n                if (!signatureImageInfos.isEmpty()) {\n                    val displayedImageInfo = signatureImageInfos.iterator().next()\n                    val image: Image = ImageUtil.getImage(context, displayedImageInfo)\n                    personDetails.portraitImage = image.bitmapImage\n                    personDetails.portraitImageBase64 = image.base64Image\n                }\n            } catch (e: Exception) {\n                Log.w(\"\", e)\n            }\n            publishProgress(\"Reading Security Options\")\n\n            // -- Security Options (if exist) -- //\n            try {\n                val dg14In = service.getInputStream(PassportService.EF_DG14)\n                val dg14File = DG14File(dg14In)\n                val dg14StoredHash = sodFile.dataGroupHashes[14]\n                val dg14ComputedHash = digest.digest(dg14File.encoded)\n                Log.d(\n                    \"\",\n                    \"DG14 Stored Hash: \" + StringUtil.byteArrayToHex(dg14StoredHash!!)\n                )\n                Log.d(\n                    \"\",\n                    \"DG14 Computed Hash: \" + StringUtil.byteArrayToHex(dg14ComputedHash)\n                )\n                if (Arrays.equals(dg14StoredHash, dg14ComputedHash)) {\n                    Log.d(\n                        \"\",\n                        \"DG14 Hashes are matched\"\n                    )\n                } else {\n                    hashesMatched = false\n                }\n\n                // Chip Authentication\n                val eaccaResults: MutableList<EACCAResult> = ArrayList()\n                val chipAuthenticationPublicKeyInfos: MutableList<ChipAuthenticationPublicKeyInfo> =\n                    ArrayList()\n                var chipAuthenticationInfo: ChipAuthenticationInfo? = null\n                if (!dg14File.securityInfos.isEmpty()) {\n                    for (securityInfo in dg14File.securityInfos) {\n                        Log.d(\n                            \"\",\n                            \"DG14 Security Info Identifier: \" + securityInfo.objectIdentifier\n                        )\n                        if (securityInfo is ChipAuthenticationInfo) {\n                            chipAuthenticationInfo = securityInfo\n                        } else if (securityInfo is ChipAuthenticationPublicKeyInfo) {\n                            chipAuthenticationPublicKeyInfos.add(securityInfo)\n                        }\n                    }\n                    for (chipAuthenticationPublicKeyInfo in chipAuthenticationPublicKeyInfos) {\n                        if (chipAuthenticationInfo != null) {\n                            val eaccaResult = service.doEACCA(\n                                chipAuthenticationInfo.keyId,\n                                chipAuthenticationInfo.objectIdentifier,\n                                chipAuthenticationInfo.protocolOIDString,\n                                chipAuthenticationPublicKeyInfo.subjectPublicKey\n                            )\n                            eaccaResults.add(eaccaResult)\n                        } else {\n                            Log.d(\n                                \"\",\n                                \"Chip Authentication failed for key: $chipAuthenticationPublicKeyInfo\"\n                            )\n                        }\n                    }\n                    if (eaccaResults.size == 0) chipAuth = false\n                }\n\n                /*\n                    if (paceSucceeded) {\n                        service.doEACTA(caReference, terminalCerts, privateKey, null, eaccaResults.get(0), mrzInfo.getDocumentNumber())\n                    } else {\n                        service.doEACTA(caReference, terminalCerts, privateKey, null, eaccaResults.get(0), paceSucceeded)\n                    }\n                */\n            } catch (e: Exception) {\n                Log.w(\"\", e)\n            }\n            publishProgress(\"Reading Document (Active Authentication) Public Key\")\n\n            // -- Document (Active Authentication) Public Key -- //\n            try {\n                val dg15In = service.getInputStream(PassportService.EF_DG15)\n                val dg15File = DG15File(dg15In)\n                val dg15StoredHash = sodFile.dataGroupHashes[15]\n                val dg15ComputedHash = digest.digest(dg15File.encoded)\n                Log.d(\n                    \"\",\n                    \"DG15 Stored Hash: \" + StringUtil.byteArrayToHex(dg15StoredHash!!)\n                )\n                Log.d(\n                    \"\",\n                    \"DG15 Computed Hash: \" + StringUtil.byteArrayToHex(dg15ComputedHash)\n                )\n                if (Arrays.equals(dg15StoredHash, dg15ComputedHash)) {\n                    Log.d(\n                        \"\",\n                        \"DG15 Hashes are matched\"\n                    )\n                } else {\n                    hashesMatched = false\n                }\n                val publicKey = dg15File.publicKey\n                val publicKeyAlgorithm = publicKey.algorithm\n\n                // Active Authentication\n                if (\"EC\" == publicKeyAlgorithm || \"ECDSA\" == publicKeyAlgorithm) {\n                    digestAlgorithm =\n                        Util.inferDigestAlgorithmFromSignatureAlgorithm(\"SHA1WithRSA/ISO9796-2\")\n                }\n                val sr = SecureRandom()\n                val challenge = ByteArray(8)\n                sr.nextBytes(challenge)\n                val result = service.doAA(\n                    dg15File.publicKey,\n                    sodFile.digestAlgorithm,\n                    sodFile.signerInfoDigestAlgorithm,\n                    challenge\n                )\n\n                activeAuth = SecurityUtil.verifyAA(\n                    dg15File.publicKey,\n                    digestAlgorithm,\n                    digestEncryptionAlgorithm,\n                    challenge,\n                    result.response\n                )\n                Log.d(\n                    \"\",\n                    StringUtil.byteArrayToHex(result.response)\n                )\n            } catch (e: Exception) {\n                Log.w(\"\", e)\n            }\n            eDocument.docType = docType;\n            eDocument.personDetails = personDetails;\n            eDocument.additionalPersonDetails = additionalPersonDetails;\n            eDocument.isPassiveAuth = hashesMatched;\n            eDocument.isActiveAuth = activeAuth;\n            eDocument.isChipAuth = chipAuth;\n\n\n        } catch (e: Exception) {\n            return e\n        }\n        return null\n    }\n\n    override fun onPostExecute(exception: java.lang.Exception?) {\n        exception?.printStackTrace()\n\n        if (exception == null) {\n            resultSubject.onNext(eDocument)\n        } else {\n            resultSubject.onError(Throwable(\"Error with reading task\"))\n        }\n    }\n}\n\n\nclass SODFileOwn(inputStream: InputStream?) : SODFile(inputStream) {\n    fun readASN1Data(): ByteArray? {\n        val a = SODFile::class.java.getDeclaredField(\"signedData\");\n        a.isAccessible = true\n\n        val v: SignedData = a.get(this) as SignedData\n\n        return v.encapContentInfo.content.toASN1Primitive().encoded\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/freedomtool/feature/onBoarding/logic/NfcReaderTask.kt b/app/src/main/java/org/freedomtool/feature/onBoarding/logic/NfcReaderTask.kt
--- a/app/src/main/java/org/freedomtool/feature/onBoarding/logic/NfcReaderTask.kt	(revision 11f239f1f462cba72b2ee89b467888fcc0629536)
+++ b/app/src/main/java/org/freedomtool/feature/onBoarding/logic/NfcReaderTask.kt	(date 1709654344074)
@@ -179,7 +179,6 @@
             personDetails.nationality = mrzInfo.nationality;
             personDetails.issuerAuthority = mrzInfo.issuingState;
 
-            //TODO: don't save this
 
             eDocument.dg1 = encodedDg1File
 
